<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class PbcReminder extends Model
{
    use HasFactory;

    protected $fillable = [
        'remindable_type',
        'remindable_id',
        'subject',
        'message',
        'type',
        'method',
        'scheduled_at',
        'sent_at',
        'days_before_due',
        'sent_by',
        'sent_to',
        'status',
        'delivery_details',
        'read_at',
        'is_auto',
        'auto_settings',
    ];

    protected $casts = [
        'scheduled_at' => 'datetime',
        'sent_at' => 'datetime',
        'read_at' => 'datetime',
        'days_before_due' => 'integer',
        'is_auto' => 'boolean',
        'auto_settings' => 'array',
    ];

    // Relationships
    public function remindable()
    {
        return $this->morphTo();
    }

    public function sender()
    {
        return $this->belongsTo(User::class, 'sent_by');
    }

    public function recipient()
    {
        return $this->belongsTo(User::class, 'sent_to');
    }

    public function auditLogs()
    {
        return $this->morphMany(AuditLog::class, 'model');
    }

    // Scopes
    public function scopeScheduled($query)
    {
        return $query->where('status', 'scheduled');
    }

    public function scopeSent($query)
    {
        return $query->where('status', 'sent');
    }

    public function scopeFailed($query)
    {
        return $query->where('status', 'failed');
    }

    public function scopeCancelled($query)
    {
        return $query->where('status', 'cancelled');
    }

    public function scopeAutoGenerated($query)
    {
        return $query->where('is_auto', true);
    }

    public function scopeManual($query)
    {
        return $query->where('is_auto', false);
    }

    public function scopeDueToSend($query)
    {
        return $query->where('status', 'scheduled')
                    ->where('scheduled_at', '<=', now());
    }

    public function scopeByMethod($query, $method)
    {
        return $query->where('method', $method);
    }

    public function scopeByType($query, $type)
    {
        return $query->where('type', $type);
    }

    public function scopeUnread($query)
    {
        return $query->whereNull('read_at');
    }

    public function scopeRead($query)
    {
        return $query->whereNotNull('read_at');
    }

    // Helper methods
    public function isPending()
    {
        return $this->status === 'scheduled' && $this->scheduled_at->isFuture();
    }

    public function isDue()
    {
        return $this->status === 'scheduled' && $this->scheduled_at->isPast();
    }

    public function isSent()
    {
        return $this->status === 'sent';
    }

    public function isFailed()
    {
        return $this->status === 'failed';
    }

    public function isCancelled()
    {
        return $this->status === 'cancelled';
    }

    public function isRead()
    {
        return !is_null($this->read_at);
    }

    public function getStatusBadgeClass()
    {
        return match($this->status) {
            'scheduled' => $this->isDue() ? 'badge-warning' : 'badge-secondary',
            'sent' => 'badge-success',
            'failed' => 'badge-danger',
            'cancelled' => 'badge-dark',
            default => 'badge-light'
        };
    }

    public function getTypeBadgeClass()
    {
        return match($this->type) {
            'initial' => 'badge-info',
            'follow_up' => 'badge-primary',
            'urgent' => 'badge-warning',
            'final_notice' => 'badge-danger',
            default => 'badge-secondary'
        };
    }

    public function getDisplayTypeAttribute()
    {
        return ucwords(str_replace('_', ' ', $this->type));
    }

    public function getDisplayMethodAttribute()
    {
        return ucfirst($this->method);
    }

    public function getDisplayStatusAttribute()
    {
        return ucfirst($this->status);
    }

    public function canBeCancelledBy(User $user)
    {
        // System admin can cancel all
        if ($user->isSystemAdmin()) {
            return true;
        }

        // Sender can cancel if not yet sent
        if ($this->sent_by === $user->id && $this->status === 'scheduled') {
            return true;
        }

        // Project team members can cancel reminders for their projects
        if ($this->remindable_type === PbcRequest::class) {
            $request = $this->remindable;
            $teamMemberIds = $request->project->getTeamMembers()->pluck('id')->toArray();
            return in_array($user->id, $teamMemberIds) && $this->status === 'scheduled';
        }

        return false;
    }

    public function canBeEditedBy(User $user)
    {
        // Only scheduled reminders can be edited
        if ($this->status !== 'scheduled') {
            return false;
        }

        // System admin can edit all
        if ($user->isSystemAdmin()) {
            return true;
        }

        // Sender can edit their own reminders
        if ($this->sent_by === $user->id) {
            return true;
        }

        return false;
    }

    public function send()
    {
        try {
            $success = false;
            $deliveryDetails = '';

            switch ($this->method) {
                case 'email':
                    $success = $this->sendEmail();
                    break;
                case 'sms':
                    $success = $this->sendSms();
                    break;
                case 'system':
                    $success = $this->sendSystemNotification();
                    break;
            }

            if ($success) {
                $this->update([
                    'status' => 'sent',
                    'sent_at' => now(),
                    'delivery_details' => $deliveryDetails,
                ]);

                // Log the activity
                AuditLog::create([
                    'user_id' => $this->sent_by,
                    'action' => 'sent_reminder',
                    'model_type' => self::class,
                    'model_id' => $this->id,
                    'description' => "Reminder sent to {$this->recipient->name} via {$this->method}",
                    'category' => 'pbc_request',
                    'severity' => 'low',
                ]);
            } else {
                $this->update([
                    'status' => 'failed',
                    'delivery_details' => $deliveryDetails,
                ]);
            }

            return $success;

        } catch (\Exception $e) {
            $this->update([
                'status' => 'failed',
                'delivery_details' => $e->getMessage(),
            ]);

            return false;
        }
    }

    private function sendEmail()
    {
        // Implement email sending logic
        // This would integrate with your mail system

        try {
            \Mail::to($this->recipient->email)->send(
                new \App\Mail\PbcReminderMail($this)
            );
            return true;
        } catch (\Exception $e) {
            \Log::error('Failed to send reminder email: ' . $e->getMessage());
            return false;
        }
    }

    private function sendSms()
    {
        // Implement SMS sending logic
        // This would integrate with your SMS provider

        try {
            // SMS implementation would go here
            \Log::info("SMS reminder would be sent to: {$this->recipient->contact_number}");
            return true;
        } catch (\Exception $e) {
            \Log::error('Failed to send reminder SMS: ' . $e->getMessage());
            return false;
        }
    }

    private function sendSystemNotification()
    {
        // Create in-app notification
        try {
            $this->recipient->notify(
                new \App\Notifications\PbcReminderNotification($this)
            );
            return true;
        } catch (\Exception $e) {
            \Log::error('Failed to send system notification: ' . $e->getMessage());
            return false;
        }
    }

    public function cancel($cancelledBy = null)
    {
        $this->update([
            'status' => 'cancelled',
            'delivery_details' => 'Cancelled by ' . ($cancelledBy ? User::find($cancelledBy)->name : 'system'),
        ]);

        return $this;
    }

    public function reschedule($newScheduledAt)
    {
        $this->update([
            'scheduled_at' => $newScheduledAt,
            'status' => 'scheduled',
        ]);

        return $this;
    }

    public function markAsRead()
    {
        $this->update(['read_at' => now()]);
        return $this;
    }

    public function getRemindableDisplayName()
    {
        switch ($this->remindable_type) {
            case PbcRequest::class:
                return "PBC Request: {$this->remindable->title}";
            case PbcRequestItem::class:
                return "PBC Item: {$this->remindable->getDisplayName()}";
            case PbcSubmission::class:
                return "Document: {$this->remindable->original_filename}";
            default:
                return $this->remindable_type;
        }
    }

    public function getScheduledAtFormatted()
    {
        return $this->scheduled_at->format('M j, Y \a\t g:i A');
    }

    public function getSentAtFormatted()
    {
        return $this->sent_at ? $this->sent_at->format('M j, Y \a\t g:i A') : null;
    }

    public function getTimeUntilSend()
    {
        if ($this->status !== 'scheduled') {
            return null;
        }

        return $this->scheduled_at->diffForHumans();
    }

    public static function createAutoReminder($remindable, $sentTo, $type = 'follow_up', $daysBefore = 3)
    {
        // Determine due date based on remindable type
        $dueDate = null;
        if ($remindable instanceof PbcRequest) {
            $dueDate = $remindable->due_date;
        } elseif ($remindable instanceof PbcRequestItem) {
            $dueDate = $remindable->due_date;
        }

        if (!$dueDate) {
            return null;
        }

        $scheduledAt = $dueDate->subDays($daysBefore);

        // Don't create reminders for past dates
        if ($scheduledAt->isPast()) {
            return null;
        }

        $subject = match($type) {
            'initial' => 'New PBC Request Assigned',
            'follow_up' => 'PBC Reminder: Action Required',
            'urgent' => 'Urgent: PBC Items Due Soon',
            'final_notice' => 'Final Notice: PBC Items Overdue',
            default => 'PBC Reminder'
        };

        $message = self::generateAutoReminderMessage($remindable, $type);

        return static::create([
            'remindable_type' => get_class($remindable),
            'remindable_id' => $remindable->id,
            'subject' => $subject,
            'message' => $message,
            'type' => $type,
            'method' => 'email',
            'scheduled_at' => $scheduledAt,
            'days_before_due' => $daysBefore,
            'sent_by' => 1, // System user
            'sent_to' => $sentTo,
            'status' => 'scheduled',
            'is_auto' => true,
            'auto_settings' => [
                'generated_at' => now(),
                'remindable_type' => get_class($remindable),
                'reminder_type' => $type,
            ],
        ]);
    }

    private static function generateAutoReminderMessage($remindable, $type)
    {
        $name = '';
        $details = '';

        if ($remindable instanceof PbcRequest) {
            $name = $remindable->title;
            $details = "Client: {$remindable->client_name}";
        } elseif ($remindable instanceof PbcRequestItem) {
            $name = $remindable->getDisplayName();
            $details = "Request: {$remindable->pbcRequest->title}";
        }

        $urgencyText = match($type) {
            'initial' => 'A new PBC request has been assigned to you.',
            'follow_up' => 'This is a friendly reminder about your pending PBC items.',
            'urgent' => 'Your PBC items are due soon. Please take immediate action.',
            'final_notice' => 'Your PBC items are now overdue. Please submit immediately.',
            default => 'You have pending PBC items that require attention.'
        };

        return "Dear User,\n\n{$urgencyText}\n\n{$name}\n{$details}\n\nPlease log in to the PBC system to review and submit the required documents.\n\nThank you.";
    }

    public function duplicate($newRecipient, $newScheduledAt = null)
    {
        $newReminder = $this->replicate();
        $newReminder->sent_to = $newRecipient;
        $newReminder->scheduled_at = $newScheduledAt ?? $this->scheduled_at;
        $newReminder->status = 'scheduled';
        $newReminder->sent_at = null;
        $newReminder->read_at = null;
        $newReminder->delivery_details = null;
        $newReminder->save();

        return $newReminder;
    }
}
